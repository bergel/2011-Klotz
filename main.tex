
%\documentclass{sig-alternate}

% English flaws:
% "can be made ON ..." and not "can be made upon"
% "disadvantage OF disruptING" and not " disadvantage to disrupt"
% "requesting something" and not "requesting for something"


%\documentclass[runningheads]{llncs}

%\documentclass[times, 10pt,twocolumn]{article} 
%\documentclass[preprint,10pt]{sigplanconf}

\documentclass[runningheads]{llncs}
%\documentclass{sig-alternate}

% constants
\newcommand{\Title}{Klotz: Agile 3D Visualization}
\newcommand{\TitleShort}{\Title}
\newcommand{\Authors}{Ricardo Jacas~~~~~Alexandre Bergel}
\newcommand{\AuthorsShort}{R. Jacas, A. Bergel}

% packages
\usepackage{xspace}
\usepackage{ifthen}
\usepackage{amsbsy}
\usepackage{amssymb}
\usepackage{balance}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{needspace}
\usepackage{microtype}
\usepackage{bold-extra}


% references
\usepackage[colorlinks]{hyperref}
\usepackage[all]{hypcap}
\setcounter{tocdepth}{2}
\hypersetup{
	colorlinks=true,
	urlcolor=black,
	linkcolor=black,
	citecolor=black,
	plainpages=false,
	bookmarksopen=true,
	pdfauthor={\Authors},
	pdftitle={\Title}}

\def\chapterautorefname{Chapter}
\def\appendixautorefname{Appendix}
\def\sectionautorefname{Section}
\def\subsectionautorefname{Section}
\def\figureautorefname{Figure}
\def\tableautorefname{Table}
\def\listingautorefname{Listing}

% source code
\usepackage{xcolor}
\usepackage{textcomp}
\usepackage{listings}
\definecolor{source}{gray}{0.9}
\lstset{
	language={},
	% characters
	tabsize=3,
	upquote=true,
	escapechar={!},
	keepspaces=true,
	breaklines=true,
	alsoletter={\#:},
	breakautoindent=true,
	columns=fullflexible,
	showstringspaces=false,
	basicstyle=\footnotesize\sffamily,
	% background
	frame=single,
    framerule=0pt,
	backgroundcolor=\color{source},
	% numbering
	numbersep=5pt,
	numberstyle=\tiny,
	numberfirstline=true,
	% captioning
	captionpos=b,
	% formatting (html)
	moredelim=[is][\textbf]{<b>}{</b>},
	moredelim=[is][\textit]{<i>}{</i>},
	moredelim=[is][\color{red}\uwave]{<u>}{</u>},
	moredelim=[is][\color{red}\sout]{<del>}{</del>},
	moredelim=[is][\color{blue}\underline]{<ins>}{</ins>}}
\newcommand{\ct}{\lstinline[backgroundcolor=\color{white},basicstyle=\footnotesize\ttfamily]}
\newcommand{\lct}[1]{{\small\tt #1}}

% tikz
% \usepackage{tikz}
% \usetikzlibrary{matrix}
% \usetikzlibrary{arrows}
% \usetikzlibrary{external}
% \usetikzlibrary{positioning}
% \usetikzlibrary{shapes.multipart}
% 
% \tikzset{
% 	every picture/.style={semithick},
% 	every text node part/.style={align=center}}

% proof-reading
\usepackage{xcolor}
\usepackage[normalem]{ulem}
\newcommand{\ra}{$\rightarrow$}
\newcommand{\ugh}[1]{\textcolor{red}{\uwave{#1}}} % please rephrase
\newcommand{\ins}[1]{\textcolor{blue}{\uline{#1}}} % please insert
\newcommand{\del}[1]{\textcolor{red}{\sout{#1}}} % please delete
\newcommand{\chg}[2]{\textcolor{red}{\sout{#1}}{\ra}\textcolor{blue}{\uline{#2}}} % please change
\newcommand{\chk}[1]{\textcolor{ForestGreen}{#1}} % changed, please check

% comments \nb{label}{color}{text}
\newboolean{showcomments}
\setboolean{showcomments}{true}
\ifthenelse{\boolean{showcomments}}
	{\newcommand{\nb}[3]{
		{\colorbox{#2}{\bfseries\sffamily\scriptsize\textcolor{white}{#1}}}
		{\textcolor{#2}{\sf\small$\blacktriangleright$\textit{#3}$\blacktriangleleft$}}}
	 \newcommand{\version}{\emph{\scriptsize$-$Id$-$}}}
	{\newcommand{\nb}[2]{}
	 \newcommand{\version}{}}
\newcommand{\rev}[2]{\nb{Reviewer #1}{red}{#2}}
\newcommand{\ab}[1]{\nb{Alexandre}{blue}{#1}}
\newcommand{\vp}[1]{\nb{Vanessa}{orange}{#1}}

% graphics: \fig{position}{percentage-width}{filename}{caption}
\DeclareGraphicsExtensions{.png,.jpg,.pdf,.eps,.gif}
\graphicspath{{figures/}}
\newcommand{\fig}[4]{
	\begin{figure}[#1]
		\centering
		\includegraphics[width=#2\textwidth]{#3}
		\caption{\label{fig:#3}#4}
	\end{figure}}
\newcommand{\largefig}[4]{
	\begin{figure*}[#1]
		\centering
		\includegraphics[width=#2\textwidth]{#3}
		\caption{\label{fig:#3}#4}
	\end{figure*}}

% abbreviations
\newcommand{\ie}{\emph{i.e.,}\xspace}
\newcommand{\eg}{\emph{e.g.,}\xspace}
\newcommand{\etc}{\emph{etc.}\xspace}
\newcommand{\etal}{\emph{et al.}\xspace}

% lists
\newenvironment{bullets}[0]
	{\begin{itemize}}
	{\end{itemize}}

\newcommand{\seclabel}[1]{\label{sec:#1}}
\newcommand{\figlabel}[1]{\label{fig:#1}}
\newcommand{\figref}[1]{Figure~\ref{fig:#1}}
\newcommand{\secref}[1]{Section~\ref{sec:#1}}
\newcommand{\tablabel}[1]{\label{tab:#1}}
\newcommand{\tabref}[1]{Table~\ref{tab:#1}}

\newcommand{\myparagraph}[1]{\noindent \textbf{#1.}}

%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
%SPRINGER
%\title{Reconciling Static Type Declaration and Dynamic Scripting Languages}
%\author{Alexandre Bergel}
%\authorrunning{A. Bergel}
%\institute{ADAM Project, INRIA Futurs, Lille, France\\
%\co{\href{http://www.bergel.eu}{www.bergel.eu}}\\
%}

%ACM
%\conferenceinfo{ECOOP}{'11}

\title{\Title}
\titlerunning{\Title}

%\author{Alexandre Bergel\\
%Pleiad Lab, Department of Computer Science (DCC),\\ University of Chile, Santiago, Chile\\ [1 ex]
%\href{http://bergel.eu}{http://bergel.eu}
%}

\author{\Authors}
\authorrunning{\AuthorsShort}

\institute{PLEIAD Lab, Department of Computer Science (DCC), \\University of Chile, Santiago, Chile\\
\url{ricardo.jacas@gmail.com}~~~~
\url{http://bergel.eu}
}


\newcommand{\spp}{~~~~~~~}

\maketitle

%\cvsversion

%\begin{center}
%\textbf{Accepted at ECOOP'11 - Do not distribute, this is not the final version}
%\end{center}

\begin{abstract}
% What is the problem


% Why is the problem a problem?
% What's the surprising Idea?
% What's the consequence?
\end{abstract}

%\category{D.3.3}{Programming Languages}{Language Constructs and Features}
%\category{D.1.5}{Programming Languages}{Object-oriented Programming}
%\terms{Language, Design}
%\keywords{Multi-language system, interoperability, SmalltalkLite, JavaLite, dynamic languages}


%\begin{figure}[!]
%\begin{center}
%\includegraphics[scale=0.68]{figures/controlleddisruption}
%\caption{The method \co{senseAndSend} is cut down into small pieces, called fragments.} \figlabel{controlleddisruption}
%\end{center}
%\end{figure}

%:%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\emph{Note for the proceeding reader: this paper makes use of colors. Although not mandatory for its understanding, an online (colored) version of this paper will ease the reading.}

\section{Introduction} \seclabel{introduction}

% What is the problem
% Why is the problem a problem?
% What's the surprising Idea?
% What's the consequence?

%:%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Klotz} \seclabel{klotz}

%=======
\subsection{Klotz in a nutshell} \seclabel{nutshell}
Klotz is a Framework, based on simple 3D graphic elements,
that are meant to work as metrics to specify characteristics of
code. The elements to work with are cubes and edges between them.

The goal of Klotz is to offer a flexible solution to visualize software 
in 3 dimensions. Klotz offers a scripting language, an API and an easel to 
``compose'' a visualization. 

The example below shows this very main goal: the script creates a group of
\emph{nodes} that represent some objects (in this case the \emph{classes} 
of our \emph{model}).The instruction \emph{applyLayout} sets the method 
the \emph{cubes} will follow to display themselves (in this case on a 
sphere). And after adding another \emph{cube} at the center (the basic 
position for any \emph{cube}), by using \emph{edges}, it defines the way 
every \emph{edge} will be draw (the \emph{edge} depends on the previous 
definition of the \emph{cubes}).

\begin{lstlisting}
| elementsToVisualize |
elementsToVisualize := KLEaselCommand  subclasses.
view nodes: elementsToVisualize.
view applyLayout: KLSphereLayout new.

view node: KLEaselCommand using: (KLCube new fillColor: Color random).
view edges: elementsToVisualize from: #yourself to: #superclass.   
\end{lstlisting}

\fig{}{0.5}{figure1.png}{KLEaselCommand subclasses.}


%=======
\subsection{Scripting visualizations with Klotz} \seclabel{scripting}
The Klotz scripting lenguage is based on Pharo Smalltalk
(since the application is made on it) and 4 basic principles
to manage the interaction between the elements on the \emph{view}:
The use of \emph{nodes}(i) to represent the elements that are
displayed, \emph{edges}(ii) to represent the relationship between
the selected \emph{nodes}, \emph{Layouts}(iii) to define the way the
\emph{view} distributes the objetcs on itself, and a special value
system defined by Pharo symbols used to access to properties of
the object being modeled (iv).  

The scripting language supports 4 diferent ways of defining \emph{nodes}:
The instructions \emph{node:} and \emph{nodes:} define standard 
\emph{nodes}(blue colored, "1" length edged \emph{cubes}), to set 1 or many 
\emph{nodes} at the same time, respectively.
\begin{lstlisting}
view node: Magnitude.
view node: Number.
view node: Time    
\end{lstlisting}
\fig{}{0.3}{figure2.png}{Magnitude class with 2 of his subclasses.}
Other way to define them, and customise the \emph{cubes} related to the 
\emph{nodes}, is by using the instructions \emph{node: using:} and 
\emph{nodes: using:}, both instructions are meant to directly define 
the \emph{cube} that will represent the inner \emph{model} of the \emph{node}, 
or each \emph{node} in the second case.
\begin{lstlisting}
view nodes: Magnitude subclasses using: (KLCube new height: #numberOfInstanceVariables)    
\end{lstlisting}
\fig{}{0.5}{figure3.png}{Magnitude subclasses, the heights shows the number of instance variables.}

Just like it happens with the \emph{nodes}, the \emph{edges} can be defined in 
4 ways: The instructions \emph{edge: from: to:} and \emph{edges: from: to:} 
apply, respectively, the \emph{edge} (\emph{edges}) between 2 cubes, each \emph{edge}.
\begin{lstlisting}
view nodes: (1 to: 5).	
view edges: (1 to: 4) from: #yourself to: 5 
\end{lstlisting}
\fig{}{0.5}{figure4.png}{Basic edges}

And also as the previous definition the keyword \emph{using:} is used
to define the metrics of the \emph{edge} itself.  
\begin{lstlisting}
view nodes: (1 to: 5).	
view edges: (1 to: 4) from: #yourself to: 5 using: (KLLine new width: #yourself)
\end{lstlisting}
\fig{}{0.5}{figure5.png}{Basic edges, using metrics}

To apply \emph{Layouts} on the current \emph{nodes} the scripting
language uses the instruction \emph{applyLayout:}. \emph{Layouts}
define the methods (or metrics) that will be used to decide how
to display the elements.The application of a \emph{Layout} will 
affect every \emph{node}(\emph{edge}) defined before itself.
\begin{lstlisting}
| colors |
colors := (Color colorNames collect: 
	 [:each | Color fromString: (each asString)]). "colors as Colors"
view nodes: colors using: (KLCube new fillColor: #yourself).
view applyLayout: (KLCubeLayout new).
\end{lstlisting}
\fig{}{0.3}{figure6.png}{All Colors available in Pharo}
 
The special value system mentioned before is a way of sending
mesages to \emph{nodes} or \emph{edges} that will be evaluated
before drawing, and will mean something specific at that context:
keywords like \emph{yourself}, \emph{class}, \emph{subclass}, etc.
Who are mesages in Pharo, are interpreted by the graphic
elements (\emph{cubes} and \emph{lines}) to define values
coresponding to \emph{nodes} (\emph{edges}) information. 
%=======
\subsection{The third dimension} \seclabel{3d}

\paragraph{Distinguish the depth}: 
A visualization contains one unique light. 
A colorless light is at the same position than the camera. 
Maximum intensity when a face has orthogonal to the camera.

\paragraph{Managing perspective}: %:not implemented yet xD
The perspective can be managed, and parametrized,
in order to emphasize minor (or major) changes on the same
\emph{model}. The easel provides commands to increase 
(decrease) the perspective, where increasing the
perspective means to enlarge the length of the edges on the
third dimention. 

\paragraph{Commands in the easel}: 
In order to manage the position of the viewer the easel 
contains 6 commands to rotate, it provides rotation on 
every axis, on both directions. It includes commands
to rotate around the X axis (up and down), around the
Y axis (rotate left, rotate right) and aroun the Z axis
(left and right). It also contains commands to manage
the current zoom of the \emph{view} (Zoom in and Zoom out),
an example panel with some script example of visualizations
and a previous scripts pane, to remember prior launched examples
on the easel. % add commands to manage perspective
   

\paragraph{Layout}:
The main objective of having a 3D engine is to have richer 
\emph{layouts} capable of representing the same \emph{models} 
that can be generated in 2D, but with the posibility of adding 
some useful metrics on the third dimention. Or to have 
completely new ways of analisis, making good use of the 3 
dimensions available.
Some examples:

\emph{Cube Layout}: This \emph{layout} display object as a "cube",
it calculates the nearest perfect cube (8,27,64,etc.), to the
number of elements, and display the \emph{nodes}, cube root 
of the result for each direction. if the element are less,
it leaves the rest blank.
\begin{lstlisting}
view 
	node: 1 using: (KLCube new width: 3; height: 5; depth: 2; yourself);
	node: 2 using: (KLCube new width: 2; height: 8; depth: 8; yourself);
	node: 3 using: (KLCube new width: 3; height: 5; depth: 2; yourself);
	node: 4 using: (KLCube new width: 1; height: 2; depth: 3; yourself);
	node: 5 using: (KLCube new width: 2; height: 2; depth: 4; yourself);
	node: 6.
view applyLayout: (KLCubeLayout new). 
\end{lstlisting}
\fig{}{0.3}{figure7.png}{Cube Layout}

 %:this layout's code highly smells, must be redefined
\emph{Sphere Layout}: It is a \emph{layout} that makes the display
as the \emph{nodes} were at the surface of a Sphere,centered on the
\emph{view} center. 
\begin{lstlisting}
	view nodes: Morph  subclasses.
	view applyLayout: (KLSphereLayout new).
	view node: Morph using: (KLCube new fillColor: Color random).
	view edges: (Morph  subclasses) from: #yourself to: #superclass.
\end{lstlisting}
\fig{}{0.7}{figure8.png}{Sphere Layout}

\emph{Block Layout}: It is a \emph{layout} that can be used to 
analyze diferences between packages. It works with the concept
of \emph{blocks} wich are the representation of related \emph{nodes}
as a single entity. Each \emph{block} is diferenced by color and the
chosen analysis for each \emph{block} is completely defined by the
user. The \emph{blocks} are displayed in a way that the bigger one
can be easily visualized.
\begin{lstlisting}
view applyLayout: (KLBlockLayout new
	with: {view nodes: ((PackageInfo named: 'Klotz-Example') classes) 
		using: (KLCube new height: #numberOfInstanceVariables; yourself)};
	with: {view nodes: ((PackageInfo named: 'Klotz-Morphic') classes)
		using: (KLCube new height: #numberOfInstanceVariables; yourself)};
	with: {view nodes: ((PackageInfo named: 'Klotz-Shapes') classes)
		using: (KLCube new height: #numberOfInstanceVariables; yourself)};
	with: {view nodes: ((PackageInfo named: 'Klotz-Events') classes)
		using: (KLCube new height: #numberOfInstanceVariables; yourself)};		
	with: {view nodes: ((PackageInfo named: 'Klotz-Easel') classes)
		using: (KLCube new height: #numberOfInstanceVariables; yourself)};
	with: {view nodes: ((PackageInfo named: 'Klotz-Layouts') classes)
		using: (KLCube new height: #numberOfInstanceVariables; yourself)};
	with: {view nodes: ((PackageInfo named: 'Klotz-Kernel') classes)
		using: (KLCube new height: #numberOfInstanceVariables; yourself)};
	with: {view nodes: ((PackageInfo named: 'Klotz-Normalizer') classes)
		using: (KLCube new height: #numberOfInstanceVariables; yourself)})
\end{lstlisting}
\fig{}{0.7}{figure9.png}{Block Layout}

\paragraph{Composition}

%=======
\subsection{Properties} \seclabel{properties}

\begin{itemize}
\item \emph{The visualization engine should be domain independent.}
Since a visualization software must represent abstract \emph{models}
the engine itself must have a system to generate \emph{abstract analisys},
analisys of features that are not yet evaluated when are defined, 
for any kind of (numerable) property that could be needed. This way
the \emph{model} will only define the values to be represented, not
the way they will be displayed.

\item \emph{Visualizations should be easily composed from simpler parts.}
Every visualization needs to be varible, there is no use in  defining
any posible visualization, so it must be a composition of simple elements,
that can be manage to achieve the display defined on the visualization kind.
Representing kinds of visualizations as \emph{layouts}, elements as \emph{nodes},
and relations as \emph{edges} is a easy to understand way of composing a
vizualization.
 
\item \emph{The visualization should be definable at a fine grained level.}
As mentioned before, representing visualizations as \emph{layouts}, elements as 
\emph{nodes}, and relations as \emph{edges} gives the posibility to 
manage every aspect of a visualization on its definition. Every wanted
property to be display can be include on the definition of the \emph{nodes},
any relation needed can be manage with \emph{edges} and for the actual display
there are the \emph{layouts}.

\item \emph{The visualization description should be declarative.}
In order to represent the required visualization, without having to 
actually learn the base lenguage code, the scripting lenguage itself
must express the logic of the computation without describing the control 
flow. Smalltalk is a lenguage that follows this paradigm, but this is
hardly enougth to make the script easy to follow. The actual computation
behind the system is controlled by the instructions \emph{node:/nodes:}, 
\emph{edge:/edges:} and \emph{applyLayout:}. Most times, the visualization
need more than just this instructions, it needs to control the \emph{shape}
of both \emph{nodes} and \emph{edges}, with the instruction \emph{using:}. 
For the \emph{layouts}, every \emph{layout} contains its own structure to 
define its parameters.   
\end{itemize}

%:%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Applications} \seclabel{applications}

%=======
\subsection{Codecity}
A first application that come in handy, using the \emph{Block Layout},
is to "build" a codecity, to represent the code of an entire program
in a single visualization. To achieve a visualization that actually 
displays a program, in a system where the visualization are not focus
on that matter, the definition of the visualization must know contain
some of its information.

The following code displays, the most usefull to mesure, properties of 
2 packages of the \emph{Compiler} system of Pharo:
\begin{lstlisting}
view applyLayout: (KLBlockLayout new
	with: {view nodes: ((PackageInfo named:'Compiler-ParseNodes') classes) 
		using: (KLCube new width: #numberOfMethods; 
							height: #numberOfInstanceVariables; 
							depth:#numberOfMethods;
							fillColor: Color lightBlue;
							 yourself)};
	with: {view nodes: ((PackageInfo named: 'Compiler-Kernel') classes)
		using: (KLCube new width: #numberOfMethods; 
							height: #numberOfInstanceVariables; 
							depth:#numberOfMethods;
							fillColor: Color blue;
							yourself)})
\end{lstlisting}
\fig{}{1.0}{figure10.png}{Compiler Kernel and ParseNodes}
This kind visualization expresses useful information when looking for
smelly code or wanting to do some refactoring. The code before give 3 
conclutions, among others, that come directly from figure 10:
every class of these 2 packages are highly functional, they are not
meant to actually represent a structure with lots of variables, which
is consistent with their real purpose. The \emph{ParseNodes} package
functionalities are concentrated on 3 classes (B in the figure), 
again consist with already known information (\emph{ParseNode}, 
\emph{BlockNode} and \emph{MessageNode} classes). Also the {Kernel} 
package contain clases with no instance variables at all (A in the figure),
wich is also consistent with verifiable information (every subclass of 
\emph{BytecodeEncoder} have no instance variables. 


%=======
\subsection{Scatterplot}
Tipically, to represent code properties directly as the dimentions
of the \emph{nodes} is not necesarily the best way to compare 
them, sometimes is usefull enought to compare such measures to 
just contrast the values themselves. Using a scatter plot, 
a type of mathematical diagram that use Cartesian coordinates to 
display values for 2 (or 3 on our 3D \emph{model}) variables for 
a set of data, the \emph{nodes} just represent the entity itself, 
and the properties are  parametrized with the \emph{node} position.

Using the \emph{Scatter Cube Layout}, 3D scatter plot can be defined
in a simple intruction. The following code presents an analisys of
the \emph{Klotz-Kernel} package:
\begin{lstlisting}
view nodes: ((PackageInfo named:'Klotz-Kernel') classes).
view applyLayout: 
(KLScatterCubeLayout 
	new x: #numberOfAttributes; "the blue line"
		y: #numberOfInstanceVariables; "the red line"
		z: #numberOfMethods) "the, not visible here, green line" 
\end{lstlisting}
\fig{}{0.6}{figure11.png}{The Klotz Kernel Package}
This visualization show some tendencies (figure 11):
most classes in the package are quite simple and similar,
with few attributes and instance variables (low x and y), and 
also most of those with lots of attributes and instance variables
are also those with lots of methods, high depth (high z). Knowing
this tendencies its easy to tell which classes hold great 
responsibility on the system.




%:%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation} \seclabel{implementation}
%=======
\subsection{Performance}
The current version of \emph{Klotz}, yet not optimaced, provides
support up to 10000 \emph{nodes} on screen, as well as, 
10000 \emph{edges} between these \emph{nodes}.


\fig{}{0.8}{graph1}{hello world}
\fig{}{0.8}{graph2}{hello world}

%:%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Related Work} \seclabel{relatedwork}

Lumiere~\cite{Oliv09a}

CodeCity~\cite{Wett08d}

%:%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion} \seclabel{conclusion}



%{\small 
%\paragraph{Acknowledgment.} We thank Mircea Lungu, Oscar Nierstrasz, Lukas Renggli and Romain Robbes for the multiple discussions we had and their comments on an early draft of the paper.
%We particular thank Walter Binder for his multiple discussions and advices.
%Our thanks also go to Eliot Miranda for his help on porting \compteur to Cog, the jitted virtual machine of Pharo. 
%We thank Gilad Bracha and Jan Vran\'{y} for the fruitful discussions we had.
%We also thank Andrew P. Black for his precious help on improving the paper.
%We gratefully thank Mar\'ia Jos\'e Cires for her help on the statistical part. 
%We also thank ESUG, the European Smalltalk User Group, for its financial contribution to the presentation of this paper. 
%}
%

\bibliographystyle{plain}
\bibliography{scg}


\end{document}
