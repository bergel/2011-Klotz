
%\documentclass{sig-alternate}

% English flaws:
% "can be made ON ..." and not "can be made upon"
% "disadvantage OF disruptING" and not " disadvantage to disrupt"
% "requesting something" and not "requesting for something"


%\documentclass[runningheads]{llncs}

%\documentclass[times, 10pt,twocolumn]{article} 
%\documentclass[preprint,10pt]{sigplanconf}

%\documentclass[runningheads]{llncs}
\documentclass{sig-alternate}

% constants
\newcommand{\Title}{Klotz: An Agile 3D Visualization Engine}
\newcommand{\TitleShort}{\Title}
\newcommand{\Authors}{Ricardo Jacas~~~~~Alexandre Bergel}
\newcommand{\AuthorsShort}{R. Jacas, A. Bergel}

% packages
\usepackage{xspace}
\usepackage{ifthen}
\usepackage{amsbsy}
\usepackage{amssymb}
\usepackage{balance}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{needspace}
\usepackage{microtype}
\usepackage{bold-extra}


% references
\usepackage[colorlinks]{hyperref}
\usepackage[all]{hypcap}
\setcounter{tocdepth}{2}
\hypersetup{
	colorlinks=true,
	urlcolor=black,
	linkcolor=black,
	citecolor=black,
	plainpages=false,
	bookmarksopen=true,
	pdfauthor={\Authors},
	pdftitle={\Title}}

\def\chapterautorefname{Chapter}
\def\appendixautorefname{Appendix}
\def\sectionautorefname{Section}
\def\subsectionautorefname{Section}
\def\figureautorefname{Figure}
\def\tableautorefname{Table}
\def\listingautorefname{Listing}

% source code
\usepackage{xcolor}
\usepackage{textcomp}
\usepackage{listings}
\definecolor{source}{gray}{0.9}
\lstset{
	language={},
	% characters
	tabsize=3,
	upquote=true,
	escapechar={!},
	keepspaces=true,
	breaklines=true,
	alsoletter={\#:},
	breakautoindent=true,
	columns=fullflexible,
	showstringspaces=false,
	basicstyle=\footnotesize\ttfamily,
	% background
	frame=single,
    framerule=0pt,
	backgroundcolor=\color{source},
	% numbering
	numbersep=5pt,
	numberstyle=\tiny,
	numberfirstline=true,
	% captioning
	captionpos=b,
	% formatting (html)
	moredelim=[is][\textbf]{<b>}{</b>},
	moredelim=[is][\textit]{<i>}{</i>},
	moredelim=[is][\color{red}\uwave]{<u>}{</u>},
	moredelim=[is][\color{red}\sout]{<del>}{</del>},
	moredelim=[is][\color{blue}\underline]{<ins>}{</ins>}}
\newcommand{\ct}{\lstinline[backgroundcolor=\color{white},basicstyle=\footnotesize\ttfamily]}
\newcommand{\lct}[1]{{\small\tt #1}}

% tikz
% \usepackage{tikz}
% \usetikzlibrary{matrix}
% \usetikzlibrary{arrows}
% \usetikzlibrary{external}
% \usetikzlibrary{positioning}
% \usetikzlibrary{shapes.multipart}
% 
% \tikzset{
% 	every picture/.style={semithick},
% 	every text node part/.style={align=center}}

% proof-reading
\usepackage{xcolor}
\usepackage[normalem]{ulem}
\newcommand{\ra}{$\rightarrow$}
\newcommand{\ugh}[1]{\textcolor{red}{\uwave{#1}}} % please rephrase
\newcommand{\ins}[1]{\textcolor{blue}{\uline{#1}}} % please insert
\newcommand{\del}[1]{\textcolor{red}{\sout{#1}}} % please delete
\newcommand{\chg}[2]{\textcolor{red}{\sout{#1}}{\ra}\textcolor{blue}{\uline{#2}}} % please change
\newcommand{\chk}[1]{\textcolor{ForestGreen}{#1}} % changed, please check

% comments \nb{label}{color}{text}
\newboolean{showcomments}
\setboolean{showcomments}{true}
\ifthenelse{\boolean{showcomments}}
	{\newcommand{\nb}[3]{
		{\colorbox{#2}{\bfseries\sffamily\scriptsize\textcolor{white}{#1}}}
		{\textcolor{#2}{\sf\small$\blacktriangleright$\textit{#3}$\blacktriangleleft$}}}
	 \newcommand{\version}{\emph{\scriptsize$-$Id$-$}}}
	{\newcommand{\nb}[2]{}
	 \newcommand{\version}{}}
\newcommand{\rev}[2]{\nb{Reviewer #1}{red}{#2}}
\newcommand{\ab}[1]{\nb{Alexandre}{blue}{#1}}
\newcommand{\rj}[1]{\nb{Ricardo}{green}{#1}}
\newcommand{\vp}[1]{\nb{Vanessa}{orange}{#1}}

% graphics: \fig{position}{percentage-width}{filename}{caption}
\DeclareGraphicsExtensions{.png,.jpg,.pdf,.eps,.gif}
\graphicspath{{figures/}}
\newcommand{\fig}[4]{
	\begin{figure}[#1]
		\centering
		\includegraphics[width=#2\textwidth]{#3}
		\caption{\label{fig:#3}#4}
	\end{figure}}
\newcommand{\largefig}[4]{
	\begin{figure*}[#1]
		\centering
		\includegraphics[width=#2\textwidth]{#3}
		\caption{\label{fig:#3}#4}
	\end{figure*}}

% abbreviations
\newcommand{\ie}{\emph{i.e.,}\xspace}
\newcommand{\eg}{\emph{e.g.,}\xspace}
\newcommand{\etc}{\emph{etc.}\xspace}
\newcommand{\etal}{\emph{et al.}\xspace}

% lists
\newenvironment{bullets}[0]
	{\begin{itemize}}
	{\end{itemize}}

\newcommand{\seclabel}[1]{\label{sec:#1}}
\newcommand{\figlabel}[1]{\label{fig:#1}}
\newcommand{\figref}[1]{Figure~\ref{fig:#1}}
\newcommand{\secref}[1]{Section~\ref{sec:#1}}
\newcommand{\tablabel}[1]{\label{tab:#1}}
\newcommand{\tabref}[1]{Table~\ref{tab:#1}}

\newcommand{\myparagraph}[1]{\noindent \textbf{#1.}}

%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
%SPRINGER
%\title{Reconciling Static Type Declaration and Dynamic Scripting Languages}
%\author{Alexandre Bergel}
%\authorrunning{A. Bergel}
%\institute{ADAM Project, INRIA Futurs, Lille, France\\
%\co{\href{http://www.bergel.eu}{www.bergel.eu}}\\
%}

%ACM
%\conferenceinfo{ECOOP}{'11}

\title{\Title}
%\titlerunning{\Title}

%ACM
\author{\Authors\\
Pleiad Lab, Department of Computer Science (DCC),\\ University of Chile, Santiago, Chile\\ [1 ex]
\url{ricardo.jacas@gmail.com}~~~~
\url{http://bergel.eu}
}

%Springer
%\author{\Authors}
%\authorrunning{\AuthorsShort}

%\institute{PLEIAD Lab, Department of Computer Science (DCC), \\University of Chile, Santiago, Chile\\
%\url{ricardo.jacas@gmail.com}~~~~
%\url{http://bergel.eu}
%}


\newcommand{\spp}{~~~~~~~}

\maketitle

%\begin{center}
%\textbf{Accepted at ECOOP'11 - Do not distribute, this is not the final version}
%\end{center}

\begin{abstract}
Klotz is a visualization engine that graphically represents in 3 dimensions. Visualizations are produced from an arbitrary model, typically a set of plain objects and connections between them. No preparation of the model is required to be rendered.
Klotz uses a semi-descriptive scripting language to easily and interactively build visualizations. 

Klotz offers two dedicated layouts to easily exploit the third dimension to visualize data. The block layout organizes data as a city metaphor and the scatterplot layout organizes data along 3 axes.

Klotz is entirely implemented in Pharo. The engine is fully based on the facilities offered by Morph.
% What is the problem
% Why is the problem a problem?
% What's the surprising Idea?
% What's the consequence?
\end{abstract}

%\category{D.3.3}{Programming Languages}{Language Constructs and Features}
%\category{D.1.5}{Programming Languages}{Object-oriented Programming}
%\terms{Language, Design}
%\keywords{Multi-language system, interoperability, SmalltalkLite, JavaLite, dynamic languages}


%\begin{figure}[!]
%\begin{center}
%\includegraphics[scale=0.68]{figures/controlleddisruption}
%\caption{The method \co{senseAndSend} is cut down into small pieces, called fragments.} \figlabel{controlleddisruption}
%\end{center}
%\end{figure}

%:%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\emph{Note for the proceeding reader: this paper makes use of colors. Although not mandatory for its understanding, an online (colored) version of this paper will ease the reading.}

\section{Introduction} \seclabel{introduction}

Visual displays allow the human brain to study multiple aspects of complex problems in parallel. Visualization, ``allows for a higher level of abstract, a closer mapping to the problem domain''~\cite{Petr95a}. 

Numerous frameworks have been offered by the Smalltalk community to visualize data. Mondrian\footnote{\url{http://www.moosetechnology.org/seaside/pier/tools/mondrian}}~\cite{Meye06a} is a flexible and agile visualization engine that uses two dimensional representation to visualize data.  

We built on the experienced we gained with Mondrian by proposing a new visualization engine that add a third dimension to the graphical representation. Klotz takes a new rendering engine to the main features of Mondrian, namely the scripting language and the interactive easel.

Contrary to other Smalltalk 3D visualization engines (Lumi\`ere\cite{Oliv09a}, Jun\footnote{\url{http://aokilab.kyoto-su.ac.jp/jun/index.html}}), Klotz does not rely on OpenGL or any external libraries. The generation of 3D graphics is solely based on Morph facilities. 

The paper is structured as follows:
\secref{klotz} presents the essential characteristics of Klotz. It progressively presents Klotz' features illustrated by short and concise scripts. 
\secref{applications} gives two layouts offered by Klotz.
\secref{implementation} briefly describes the main points of Klotz implementation and gives some benchmarks.
\secref{conclusion} concludes.


% What is the problem
% Why is the problem a problem?
% What's the surprising Idea?
% What's the consequence?

%:%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Klotz} \seclabel{klotz}

%=======
\subsection{Klotz in a nutshell} \seclabel{nutshell}
Klotz is an agile 3-dimensional visualization engine. Visualizations are made of cubes and lines. Contrary to other 3D visualization frameworks available on Smalltalk, Klotz maps each graphical element to an object that belongs to an user-defined domain. Visual dimensions of a graphical element is the result of applying metrics on the visualized domain. 

Klotz' objective is to offer a flexible and agile tool to visualize any arbitrary domain expressed in terms of objects and relations without any prior preparation. Visualizations are described by means of a scripting language. Consider the illustrative script:

\begin{lstlisting}[numbers=left]
| subclasses |
subclasses := KLEaselCommand subclasses.
view nodes: subclasses.
view applyLayout:  (KLSphereLayout new).

view node: KLEaselCommand using: (KLCube new fillColor: Color green).
view edges: subclasses from: #yourself to: #superclass.   
\end{lstlisting}

Line 1 defines a temporary variable \ct{models}. 
The variable is initialized in Line 2 with the all the subclasses of the class \ct{KLEaselCommand}.
Line 3 adds the objects referenced by \ct{models} into the view. Each of the subclass of \ct{KLEaselCommand} is represented by a cube.
Line 4 orders the cube along a sphere layout.

Line 6 adds a new node, \ct{KLEaselCommand} the root of the class hierarchy. The node is colored in green.
Line 7 adds as many edges there is elements in the variable \ct{models}. For each subclass, an edge is drawn from the subclass to its superclass, \ct{KLEaselCommand}. The result is depicted in \figref{figure1.png}.

\fig{h}{0.4}{figure1.png}{KLEaselCommand subclasses.}

\fig{h}{0.5}{klotz}{The Klotz Easel}

Agility of Klotz is expressed via an easel to interactively ``compose'' a visualization (\figref{klotz}). The lower part contains the scripts what is entered by the user. The upper part contains the visualization generated by the script interpretation.



%=======
\subsection{Scripting visualizations with Klotz} \seclabel{scripting}

The Klotz scripting language is plain Pharo code. Each script is based on 4 principles:

\begin{itemize}
\item elements composing the visualization are represented as \emph{nodes}. Each node may have a shape and color that reflects some characteristics of the represented node.
\item relations between elements are represented with \emph{edges}. The color and width of a shape depends on some characteristics of the edge.
\item elements may be ordered using \emph{layouts}. A layout may use edges to direct the ordering.
\item containment is expressed with a \emph{view}, an object that enables the construction of the visualization by offering numerous methods.%\ab{Is there more to say?}
\end{itemize}

%to manage the interaction between the elements on the \emph{view}:
%The use of \emph{nodes}(i) to represent the elements that are
%displayed, \emph{edges}(ii) to represent the relationship between
%the selected \emph{nodes}, \emph{Layouts}(iii) to define the way the
%\emph{view} distributes the objetcs on itself, and a special value
%system defined by Pharo symbols used to access to properties of
%the object being modeled (iv).  

The scripting language supports 4 different ways of defining nodes. 
The messages \ct{node:} create an individual node using the default visual properties (colored in blue, thin black border line). A variant of it is \ct{nodes:} to add multiple nodes in one single instruction. The script 

\begin{lstlisting}
view node: Magnitude.
view node: Number.
view node: Time    
\end{lstlisting}

is equivalent to

\begin{lstlisting}
view nodes: { Magnitude. Number . Time}
\end{lstlisting}

The result is shown in \figref{figure2.png}.

\fig{h}{0.2}{figure2.png}{Magnitude class and 2 of its subclasses.}

The visual representation may be particularized for the provided nodes. The message \ct{node:using:} and \ct{nodes:using:} allow graphical cube to be customized with metrics computed on the represented model. Consider the example, depicted in \figref{figure3.png}:

\begin{lstlisting}
view nodes: Magnitude subclasses using: (KLCube new height: #numberOfInstanceVariables)    
\end{lstlisting}

\fig{h}{0.3}{figure3.png}{Magnitude subclasses, the heights shows the number of instance variables.}

The message \ct{numberOfInstanceVariables} is sent to each of \ct{Magnitude}'s subclasses. 

Similarly with nodes edges are defined in one of four ways. The method \ct{edge:from:to:} and \ct{edges:from:to:} use default black and thin line shape offered by the view. \figref{figure4.png} shows the result of the script:

\begin{lstlisting}
view nodes: Magnitude subclasses.	
view edges: (Magnitude subclasses) from: #yourself to: MetacelloVersionNumber
\end{lstlisting}
\fig{h}{0.3}{figure4.png}{Basic edges}


% on the current \emph{nodes} the scripting
%language uses the instruction \emph{applyLayout:}. \emph{Layouts}
%define the methods (or metrics) that will be used to decide how
%to display the elements.The application of a \emph{Layout} will 
%affect every \emph{node}(\emph{edge}) defined before itself.
%\rj{color example removed :P, every "numbers" examples changed}
 
 The message \ct{edges:} \emph{domain} \ct{from:} \emph{fromSelectorOrBlock} \ct{to:} \emph{toSelectorOrBlock} constructs an edge for each element of the \emph{domain}. The source code is the result of evaluating \emph{fromSelectorOrBlock} on the considered  node and the target is obtained by evaluating  \emph{toSelectorOrBlock}. One-arg blocks and symbols are equally accepted.
 
  
%The special value system mentioned before is a way of sending
%messages to \emph{nodes} or \emph{edges} that will be evaluated
%before drawing, and will mean something specific at that context:
%keywords like \emph{yourself}, \emph{class}, \emph{subclass}, etc.
%Who are mesages in Pharo, are interpreted by the graphic
%elements (\emph{cubes} and \emph{lines}) to define values
%coresponding to \emph{nodes} (\emph{edges}) information. 

%=======

\subsection{The third dimension} \seclabel{3d}

Visualizations in third dimensions convey a ``feeling of immersion'' that Klotz is intensively exploiting. A number of tools and options are offered by either the visualization or the easel.

\paragraph{Light intensity}
A visualization contains one unique light, a white light located at the same position than the camera. The light intensity on a face is at its maximum when the face is orthogonal to the camera. When a surface of the face is close to be lined up with a light ray, the face is dark.

\paragraph{Emphasizing the perspective}
Perspective is the way a solid object is drawn on a two-dimensional surface so as to give the right impression of their height, width and depth. Our experience shows that it is difficult to precisely compare element positions when closely located from each other. Perspective may be emphasized thanks to an increase and decrease perspective commands offered by the easel.

%The perspective can be managed, and parametrized,
%in order to emphasize changes on the same
%\emph{model}. The easel provides commands to increase 
%(decrease) the perspective, where increasing the
%perspective means to enlarge the length of the edges on the
%third dimension. 

\fig{h}{0.5}{perspective}{Emphasizing the perspective}

\figref{perspective} illustrates this situation with a slight variation in the perspective.

\paragraph{Controlling the camera}
A user look at a visualization through the view camera. The easel offers six commands to rotate and move the camera along every axis. 
%The position of the camera used to render 
%In order to manage the position of the viewer the easel 
%contains 6 commands to rotate, it provides rotation on 
%every axis, on both directions. It includes commands
%to rotate around the X axis (up and down), around the
%Y axis (rotate left, rotate right) and around the Z axis
%(left and right). It also contains commands to manage
%the current zoom of the \emph{view} (Zoom in and Zoom out),
%an example panel with some script example of visualizations
%and a previous scripts pane, to remember prior launched examples
%on the easel. Finally, it contains commands to manage the 
%perspective, understanding that managing perspective means
%changing the relative position of the viewer.  
%   

\paragraph{Layout}
Nodes are ordered using a layout. The default layout that is used when no other is specified is the horizontal line layout. A layout is specified using the message \ct{applyLayout:}. Three layouts are available currently: cube layout, sphere layout and block layout.

\emph{Cube Layout}: This \emph{layout} orders the nodes as a``cube'', meaning that each edges \ab{Something strange here. Why the visualization has two rows of node?}

it calculates the nearest perfect cube (8,27,64,etc.), to the
number of elements, and display the \emph{nodes}, cube root 
of the result for each direction. if the element are less,
it leaves the rest blank.

\begin{lstlisting}
view 
	nodes: Magnitude withAllSubclasses 
	using: (KLCube new width: #numberOfInstanceVariables).
view applyLayout: (KLCubeLayout new). 
\end{lstlisting}
\fig{}{0.3}{cubeLayout}{Cube Layout}

\emph{Sphere Layout}: nodes are located on the surface of a sphere, centered on the center of the view. The following example places all the subclasses of \ct{Magnitude} on a sphere (\figref{sphereLayout}):

\begin{lstlisting}
view nodes: Magnitude subclasses. 
view applyLayout: KLSphereLayout new. 

view 
	node: Magnitude 
	using: (KLCube new fillColor: Color green). 
view 
	edges: Magnitude subclasses 
	from: #yourself 
	to: #superclass.
\end{lstlisting}
\fig{}{0.4}{sphereLayout}{Sphere Layout}

\emph{Block Layout}: nodes are hierarchically grouped and organized around a surface. Each group is uniquely colored. The assigned color is random is none is specified in the shape.

%It is a \emph{layout} that can be used to 
%analyze diferences between packages. It works with the concept
%of \emph{blocks} wich are the representation of related \emph{nodes}
%as a single entity. Each \emph{block} is diferenced by color and the
%chosen analysis for each \emph{block} is completely defined by the
%user. The \emph{blocks} are displayed in a way that the bigger one
%can be easily visualized.

The following script visualize the structure of Klotz (\figref{figure9.png}): 

\begin{lstlisting}
| shape packages block |
shape := KLCube new height: #numberOfInstanceVariables.
packages := 
	PackageInfo allPackages 
		select: [:pak | pak packageName matches: 'Klotz-*'].

block := KLBlockLayout new.
packages do: [ :pak | 
	block with: {view nodes: pak classes using: shape } ].
view applyLayout: block
	\end{lstlisting}
\fig{}{0.4}{figure9.png}{Block Layout}

The script gives a randomly chosen color to each package of Klotz. The color is used to paint the classes of each package. Each node is a colored class. The height represents the number of attributes. 

\emph{Scatterplot layout}: nodes may be located on a three dimensional Cartesian. Each node has a 3d coordinate that is determined from applying three metric on the represented model. The following script plots each class of the Klotz-Kernel package along its number of attributes, number of methods (\figref{scatterplotLayout}):

\begin{lstlisting}
view nodes: 
	((PackageInfo named:'Klotz-Kernel') classes).

view applyLayout: 
(KLScatterCubeLayout new
    <i>"blue line"</i>
    x: [:cls | cls numberOfLinesOfCode / 1000]; 
    y: #numberOfInstanceVariables; <i>"red line"</i>
    z: #numberOfMethods) <i>"green line"</i>
\end{lstlisting}

\fig{h}{0.4}{scatterplotLayout}{The Klotz Kernel Package}

%This visualization show some tendencies (figure 11):
%most classes in the package are quite simple and similar,
%with few attributes and instance variables (low x and y), and 
%also most of those with lots of attributes and instance variables
%are also those with lots of methods, high depth (high z). Knowing
%this tendencies its easy to tell which classes hold great 
%responsibility on the system.

%=======
%\subsection{Properties} \seclabel{properties}
%
%\begin{itemize}
%\item \emph{The visualization engine should be domain independent.}
%Visualization is a mean to abstract models by compressing a detailed model into a set of visual patterns. The visualization engine we built visualizes any arbitrary domain. According to the experience gained with Mondrian, this is a highly relevant characteristic.
%
%%the engine itself must have a system to generate \emph{abstract analisys},
%%analisys of features that are not yet evaluated when are defined, 
%%for any kind of (numerable) property that could be needed. This way
%%the \emph{model} will only define the values to be represented, not
%%the way they will be displayed.
%
%%\item \emph{Visualizations should be easily composed from simpler parts.}
%%Every visualization needs to be varible, there is no use in  defining
%%any posible visualization, so it must be a composition of simple elements,
%%that can be manage to achieve the display defined on the visualization kind.
%%Representing kinds of visualizations as \emph{layouts}, elements as \emph{nodes},
%%and relations as \emph{edges} is a easy to understand way of composing a
%%vizualization.
% 
%\item \emph{The visualization should be definable at a fine grained level.}
%As mentioned before, representing visualizations as \emph{layouts}, elements as 
%\emph{nodes}, and relations as \emph{edges} gives the posibility to 
%manage every aspect of a visualization on its definition. Every wanted
%property to be display can be part the definition of the \emph{nodes},
%any relation needed can be manage with \emph{edges} and for the actual display
%there are the \emph{layouts}.
%
%\item \emph{The visualization description should be declarative.}
%In order to represent the required visualization, without having to 
%actually learn the base lenguage code, the scripting lenguage itself
%must express the logic of the computation without describing the control 
%flow. Smalltalk is a lenguage that follows this paradigm, but this is
%hardly enougth to make the script easy to follow. The actual computation
%behind the system is controlled by the instructions \emph{node:/nodes:}, 
%\emph{edge:/edges:} and \emph{applyLayout:}. Most times, the visualization
%need more than just this instructions, it needs to control the \emph{shape}
%of both \emph{nodes} and \emph{edges}, with the instruction \emph{using:}. 
%For the \emph{layouts}, every \emph{layout} contains its own structure to 
%define its parameters.   
%\end{itemize}

%:%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{Applications} \seclabel{applications}
%
%%=======
%\subsection{Codecity}
%A natural application of the block layout is to visualize software as an interactive city. Consider the representation of two packages of the Pharo compiler, the parse nodes and the kernel (\figref{figure10.png}):
%
%\begin{lstlisting}
%view applyLayout: (KLBlockLayout new
%	with: {view nodes: ((PackageInfo named:'Compiler-ParseNodes') classes) 
%		using: (KLCube new width: #numberOfMethods; 
%							height: #numberOfInstanceVariables; 
%							depth:#numberOfMethods;
%							fillColor: Color lightBlue;
%							 yourself)};
%	with: {view nodes: ((PackageInfo named: 'Compiler-Kernel') classes)
%		using: (KLCube new width: #numberOfMethods; 
%							height: #numberOfInstanceVariables; 
%							depth:#numberOfMethods;
%							fillColor: Color blue;
%							yourself)})
%\end{lstlisting}
%
%\fig{}{0.55}{figure10.png}{Compiler Kernel and ParseNodes}
%
%This codecity-like visualization is useful when looking for smelly code or opportunities for code refactoring.
%
%This kind visualization expresses useful information when looking for
%smelly code or wanting to do some refactoring. The code before give 3 
%conclutions, among others, that come directly from figure 10:
%every class of these 2 packages are highly functional, they are not
%meant to actually represent a structure with lots of variables, which
%is consistent with their real purpose. The \emph{ParseNodes} package
%functionalities are concentrated on 3 classes (B in the figure), 
%again consist with already known information (\emph{ParseNode}, 
%\emph{BlockNode} and \emph{MessageNode} classes). Also the {Kernel} 
%package contain clases with no instance variables at all (A in the figure),
%wich is also consistent with verifiable information (every subclass of 
%\emph{BytecodeEncoder} have no instance variables. 
%
%
%%=======
%\subsection{Scatterplot}
%Tipically, to represent code properties directly as the dimentions
%of the \emph{nodes} is not necesarily the best way to compare 
%them, sometimes is usefull enought to compare such measures to 
%just contrast the values themselves. Using a scatter plot, 
%a type of mathematical diagram that use Cartesian coordinates to 
%display values for 2 (or 3 on our 3D \emph{model}) variables for 
%a set of data, the \emph{nodes} just represent the entity itself, 
%and the properties are  parametrized with the \emph{node} position.
%
%Using the \emph{Scatter Cube Layout}, 3D scatter plot can be defined
%in a simple intruction. The following code presents an analisys of
%the \emph{Klotz-Kernel} package:
%
%\begin{lstlisting}
%view nodes: 
%	((PackageInfo named:'Klotz-Kernel') classes).
%
%view applyLayout: 
%(KLScatterCubeLayout new
%    x: #numberOfAttributes; <i>"blue line"</i>
%    y: #numberOfInstanceVariables; <i>"red line"</i>
%    z: #numberOfMethods) <i>"green line"</i>
%\end{lstlisting}
%
%\fig{}{0.4}{figure11.png}{The Klotz Kernel Package}
%
%This visualization show some tendencies (figure 11):
%most classes in the package are quite simple and similar,
%with few attributes and instance variables (low x and y), and 
%also most of those with lots of attributes and instance variables
%are also those with lots of methods, high depth (high z). Knowing
%this tendencies its easy to tell which classes hold great 
%responsibility on the system.
%



%:%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation} \seclabel{implementation}	
The current version of \emph{Klotz}, yet not optimized, provides
support up to 1000 \emph{nodes} on screen, as well as, 
1000 \emph{edges} between these \emph{nodes}.

\fig{}{0.5}{graph1}{Benchmark (quantity vs time[ms]) for few \emph{nodes}/\emph{edges}} 

As shown in figure 12, the \emph{Easel} provides the expected results
almost in linear proportion with the quantity of \emph{nodes}, 
wich is a great result, for a graphical interface. It also shown 
not major difference between the computation of different kinds 
of \emph{Layouts}, even those using \emph{edges}. This result seem 
to be perfect, but thats only because the quantity is still not 
demanding for the system. Note that on both figures the \emph{Layout} 
with \emph{edges} have as much \emph{edges} as \emph{nodes}.  

\fig{}{0.5}{graph2}{Benchmark (quantity vs time[ms]) for lots of \emph{nodes}/\emph{edges}}

On figure 13, as mentioned before, the tendency to go in almost 
linear proportion is still there, for displaying \emph{Layouts} 
with just \emph{nodes}, but when it comes to add \emph{edges}
the proportion happens to be exponential, which is far from
a good system, but since there is no real need to actually 
display 1000 \emph{nodes} with 1000 \emph{edges} between them (and
if there is, its not common) \emph{Klotz} keeps this specification. 

%:%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Discussion} \seclabel{discussion}

The Klotz graphic generation solely uses Morph facilities. The most common approach to visualize 3d graphics is to use OpenGL, a reference in the field. We deliberately decided to not use OpenGL for a number of practical reasons:

\begin{itemize}
\item OpenGL is distributed as a set of natives libraries, depending on the operating system. Libraries are accessed within Pharo using FFI or Alien, two technologies that interoperate with native libraries. Unfortunately, the recent advances with the Pharo virtual machine significantly reduced the usability of accessing external libraries.

\item The visualizations produced with Mondrian rarely go over 2,000 nodes and 1,000 edges. It is reasonable to expect similar figure as the upper limit for Klotz. OpenGL enables sophisticated rendering, including a high number of rendered polygons and advanced light composition. We do not expect to have such a need in a close future.
\end{itemize}

Basing Klotz on OpenGL is clearly on our agenda. For this, Alien needs to gain stability, especially with the Pharo JIT virtual machine (Cog).

%:%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Related Work} \seclabel{relatedwork}
\ab{need to go over this}
\subsection{Lumiere}
Lumiere~\cite{Oliv09a} is a 3D Framework,that applies a stage metaphor.
This metaphor implies that all graphics are produced by cameras
taking pictures of 3D shapes lit by the lights of the stage. A
stage provides the setting for taking pictures of a composition 
of visual objects we call micro-worlds. Lumiere's objective
is to implement a 3D graphical support to Pharo programmers, at
a high level of abstraction. This Framework uses OpenGL libraries
designed for Pharo. As mentioned before, this libraries are 
entirely dependent of the OS and the right native OpenGL packages
within the machine itself, to be used.

On the other hand, Klotz do not represent a competitor on that 
matter, Klotz is a 3D code visualization engine, its goal is
not focus on the actual quality of the graphic interface, but 
on the expressiveness of the representation in order to achieve
a better comprehension of the code. Right now Klotz graphical
interface is a small engine that is completely based on the Morph
engine, which seems sufficient for it  purposes. This does not
mean to be the final core, eventually the system will need an
external graphic engine, probably based on OpenGL, and that can
also be Lumiere itself, but since the goal its not the actual
graphics of Klotz (and the engines take to much effort on just
configuration, external to the Klotz interface), this matter
remains pending.

\subsection{CodeCity}
CodeCity~\cite{Wett08d} is a full fledged city metaphor environment, for code
analisys. Its Visualization is based on this metaphor, and its
metrics are entirely defined (and chosen carefully) to faithfully
explain software code. This concrete approach intends to focus
not only on the visualization itself, but in the analysis of software
evolution. It also support  reverse engineering.

CodeCity is programmed in VisualWorks Smalltalk on top of the Moose 
platform, just like Lumiere, it uses OpenGL for rendering.

when it comes to Klotz, not been as powerful as Codecity, eventually, 
and depending on the programer's skills, it can implement every static 
aspect of its model. The same metrics defined on it to represent code 
can be applied to a yet customizable environment, with a simple Pharo image. 
This can be very complex and carry lots of trouble that CodeCity has 
already fixed (probably). But as said before, the main idea is not to 
create a city metaphor model, but to have a meta-model creation system, 
meant to easily display many different aspects of a code analysis on the 
same framework and with a scripting language, designed to be easy to manage.


%:%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion} \seclabel{conclusion}
\rj{i just added some extra content here}
Klotz is an agile three-dimensional visualization engine. Klotz visualizes a graph of objects, without any preparation of the objects.
Klotz meta-model system allows to change a graph definition easily, making it simple and fast to adjust a desired visualization. Been based on any object as the items represented on the node it gives great dynamism to the kind of visualization that it can provide. 
As future work, we plan to:
\begin{itemize}
\item Implement drag-and-drop support to manage the nodes easily.
\item Add an interface to see the information within the node on mouse focus, and change it dynamically.
\item Optimize and improve the graphical libraries, if possible, change to a stable, OpenGL based library, because most of them are not even functional right now. 
\item Add lots of new Layouts, and with time, other figures to use as nodes. 
\end{itemize}

\paragraph{Acknowledgment} 
We thank Patricio Plaza for his effort and participation on an early version of Klotz.

%{\small 
%\paragraph{Acknowledgment.} We thank Mircea Lungu, Oscar Nierstrasz, Lukas Renggli and Romain Robbes for the multiple discussions we had and their comments on an early draft of the paper.
%We particular thank Walter Binder for his multiple discussions and advices.
%Our thanks also go to Eliot Miranda for his help on porting \compteur to Cog, the jitted virtual machine of Pharo. 
%We thank Gilad Bracha and Jan Vran\'{y} for the fruitful discussions we had.
%We also thank Andrew P. Black for his precious help on improving the paper.
%We gratefully thank Mar\'ia Jos\'e Cires for her help on the statistical part. 
%We also thank ESUG, the European Smalltalk User Group, for its financial contribution to the presentation of this paper. 
%}
%

\bibliographystyle{plain}
\bibliography{scg}


\end{document}
