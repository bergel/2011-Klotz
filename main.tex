	
%\documentclass{sig-alternate}

% English flaws:
% "can be made ON ..." and not "can be made upon"
% "disadvantage OF disruptING" and not " disadvantage to disrupt"
% "requesting something" and not "requesting for something"


%\documentclass[runningheads]{llncs}

%\documentclass[times, 10pt,twocolumn]{article} 
%\documentclass[preprint,10pt]{sigplanconf}

%\documentclass[runningheads]{llncs}
\documentclass{sig-alternate}

% constants
\newcommand{\Title}{Klotz: An Agile 3D Visualization Engine}
\newcommand{\TitleShort}{\Title}
\newcommand{\Authors}{Ricardo Jacas~~~~~Alexandre Bergel}
\newcommand{\AuthorsShort}{R. Jacas, A. Bergel}

% packages
\usepackage{xspace}
\usepackage{ifthen}
\usepackage{amsbsy}
\usepackage{amssymb}
\usepackage{balance}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{needspace}
\usepackage{microtype}
\usepackage{bold-extra}


% references
\usepackage[colorlinks]{hyperref}
\usepackage[all]{hypcap}
\setcounter{tocdepth}{2}
\hypersetup{
	colorlinks=true,
	urlcolor=black,
	linkcolor=black,
	citecolor=black,
	plainpages=false,
	bookmarksopen=true,
	pdfauthor={\Authors},
	pdftitle={\Title}}

\def\chapterautorefname{Chapter}
\def\appendixautorefname{Appendix}
\def\sectionautorefname{Section}
\def\subsectionautorefname{Section}
\def\figureautorefname{Figure}
\def\tableautorefname{Table}
\def\listingautorefname{Listing}

% source code
\usepackage{xcolor}
\usepackage{textcomp}
\usepackage{listings}
\definecolor{source}{gray}{0.9}
\lstset{
	language={},
	% characters
	tabsize=3,
	upquote=true,
	escapechar={!},
	keepspaces=true,
	breaklines=true,
	alsoletter={\#:},
	breakautoindent=true,
	columns=fullflexible,
	showstringspaces=false,
	basicstyle=\footnotesize\ttfamily,
	% background
	frame=single,
    framerule=0pt,
	backgroundcolor=\color{source},
	% numbering
	numbersep=5pt,
	numberstyle=\tiny,
	numberfirstline=true,
	% captioning
	captionpos=b,
	% formatting (html)
	moredelim=[is][\textbf]{<b>}{</b>},
	moredelim=[is][\textit]{<i>}{</i>},
	moredelim=[is][\color{red}\uwave]{<u>}{</u>},
	moredelim=[is][\color{red}\sout]{<del>}{</del>},
	moredelim=[is][\color{blue}\underline]{<ins>}{</ins>}}
\newcommand{\ct}{\lstinline[backgroundcolor=\color{white},basicstyle=\footnotesize\ttfamily]}
\newcommand{\lct}[1]{{\small\tt #1}}

% tikz
% \usepackage{tikz}
% \usetikzlibrary{matrix}
% \usetikzlibrary{arrows}
% \usetikzlibrary{external}
% \usetikzlibrary{positioning}
% \usetikzlibrary{shapes.multipart}
% 
% \tikzset{
% 	every picture/.style={semithick},
% 	every text node part/.style={align=center}}

% proof-reading
\usepackage{xcolor}
\usepackage[normalem]{ulem}
\newcommand{\ra}{$\rightarrow$}
\newcommand{\ugh}[1]{\textcolor{red}{\uwave{#1}}} % please rephrase
\newcommand{\ins}[1]{\textcolor{blue}{\uline{#1}}} % please insert
\newcommand{\del}[1]{\textcolor{red}{\sout{#1}}} % please delete
\newcommand{\chg}[2]{\textcolor{red}{\sout{#1}}{\ra}\textcolor{blue}{\uline{#2}}} % please change
\newcommand{\chk}[1]{\textcolor{ForestGreen}{#1}} % changed, please check

% comments \nb{label}{color}{text}
\newboolean{showcomments}
\setboolean{showcomments}{true}
\ifthenelse{\boolean{showcomments}}
	{\newcommand{\nb}[3]{
		{\colorbox{#2}{\bfseries\sffamily\scriptsize\textcolor{white}{#1}}}
		{\textcolor{#2}{\sf\small$\blacktriangleright$\textit{#3}$\blacktriangleleft$}}}
	 \newcommand{\version}{\emph{\scriptsize$-$Id$-$}}}
	{\newcommand{\nb}[2]{}
	 \newcommand{\version}{}}
\newcommand{\rev}[2]{\nb{Reviewer #1}{red}{#2}}
\newcommand{\ab}[1]{\nb{Alexandre}{blue}{#1}}
\newcommand{\rj}[1]{\nb{Ricardo}{green}{#1}}
\newcommand{\vp}[1]{\nb{Vanessa}{orange}{#1}}

% graphics: \fig{position}{percentage-width}{filename}{caption}
\DeclareGraphicsExtensions{.png,.jpg,.pdf,.eps,.gif}
\graphicspath{{figures/}}
\newcommand{\fig}[4]{
	\begin{figure}[#1]
		\centering
		\includegraphics[width=#2\textwidth]{#3}
		\caption{\label{fig:#3}#4}
	\end{figure}}
\newcommand{\largefig}[4]{
	\begin{figure*}[#1]
		\centering
		\includegraphics[width=#2\textwidth]{#3}
		\caption{\label{fig:#3}#4}
	\end{figure*}}

% abbreviations
\newcommand{\ie}{\emph{i.e.,}\xspace}
\newcommand{\eg}{\emph{e.g.,}\xspace}
\newcommand{\etc}{\emph{etc.}\xspace}
\newcommand{\etal}{\emph{et al.}\xspace}

% lists
\newenvironment{bullets}[0]
	{\begin{itemize}}
	{\end{itemize}}

\newcommand{\seclabel}[1]{\label{sec:#1}}
\newcommand{\figlabel}[1]{\label{fig:#1}}
\newcommand{\figref}[1]{Figure~\ref{fig:#1}}
\newcommand{\secref}[1]{Section~\ref{sec:#1}}
\newcommand{\tablabel}[1]{\label{tab:#1}}
\newcommand{\tabref}[1]{Table~\ref{tab:#1}}

\newcommand{\myparagraph}[1]{\noindent \textbf{#1.}}

%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
%SPRINGER
%\title{Reconciling Static Type Declaration and Dynamic Scripting Languages}
%\author{Alexandre Bergel}
%\authorrunning{A. Bergel}
%\institute{ADAM Project, INRIA Futurs, Lille, France\\
%\co{\href{http://www.bergel.eu}{www.bergel.eu}}\\
%}

%ACM
%\conferenceinfo{ECOOP}{'11}

\title{\Title}
%\titlerunning{\Title}

%ACM
\author{\Authors\\
Pleiad Lab, Department of Computer Science (DCC),\\ University of Chile, Santiago, Chile\\ [1 ex]
\url{ricardo.jacas@gmail.com}~~~~
\url{http://bergel.eu}
}

%Springer
%\author{\Authors}
%\authorrunning{\AuthorsShort}

%\institute{PLEIAD Lab, Department of Computer Science (DCC), \\University of Chile, Santiago, Chile\\
%\url{ricardo.jacas@gmail.com}~~~~
%\url{http://bergel.eu}
%}


\newcommand{\spp}{~~~~~~~}

\maketitle

%\begin{center}
%\textbf{Accepted at ECOOP'11 - Do not distribute, this is not the final version}
%\end{center}

\begin{abstract}
\rj{the sentences "a set of plain objects and connections" and "no preparation of the model" seems not understandable}
Klotz is an agile 3D visualization engine. Visualizations are produced from an arbitrary model, typically a set of plain objects and connections. No preparation of the model is required to be rendered.
Klotz uses a semi-descriptive scripting language to easily and interactively build visualizations. 

Klotz, on its current version, offers four layouts to easily exploit the third dimension when visualizing data. %The block layout organizes data as a city metaphor and the scatterplot layout organizes data along 3 axes.

Klotz is entirely implemented in Pharo. The engine is fully based on the facilities offered by Morphic. 
% What is the problem
% Why is the problem a problem?
% What's the surprising Idea?
% What's the consequence?
\end{abstract}

%\category{D.3.3}{Programming Languages}{Language Constructs and Features}
%\category{D.1.5}{Programming Languages}{Object-oriented Programming}
%\terms{Language, Design}
%\keywords{Multi-language system, interoperability, SmalltalkLite, JavaLite, dynamic languages}


%\begin{figure}[!]
%\begin{center}
%\includegraphics[scale=0.68]{figures/controlleddisruption}
%\caption{The method \co{senseAndSend} is cut down into small pieces, called fragments.} \figlabel{controlleddisruption}
%\end{center}
%\end{figure}

%:%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\emph{Note for the proceeding reader: this paper makes use of colors. Although not mandatory for its understanding, an online (colored) version of this paper will ease the reading.}

\section{Introduction} \seclabel{introduction}

Visual displays allow the human brain to study multiple aspects of complex problems in parallel. Visualization, ''allows for a higher level of abstract, a closer mapping to the problem domain''~\cite{Petr95a}. 

Numerous frameworks have been offered by the Smalltalk community to visualize data. Mondrian\footnote{\url{http://www.moosetechnology.org/seaside/pier/tools/mondrian}}~\cite{Meye06a}, one of them, is a flexible and agile visualization engine that uses a two dimensional representation to visualize data.  

We are building on the experience we gained with Mondrian by proposing a new visualization engine that adds a third dimension to the graphical representation. Klotz applies the main features of Mondrian, namely the scripting language and the interactive easel, to a new rendering engine.

\rj{according to lukas we are not using "Morph facilities" but is just using the graphic canvas to draw (like Mondrian). I believe that with some explanation on the graphic engine this would be fine. Also we should remark if we only see those 2 benefits and list them, or mention others like the stability of been based on Pharo facilities or the security also provided by staying on the Pharo enviroment (i think these 2 are quite easy to see just by mentioning the installation and multi-plataform support but its a comment repeated over the review)}
Contrary to other Smalltalk 3D visualization engines (Lumi\`ere\cite{Oliv09a}, Jun\footnote{\url{http://aokilab.kyoto-su.ac.jp/jun/index.html}}), Klotz does not rely on OpenGL or any external libraries. The generation of 3D graphics is solely based on Morph facilities. The benefits are numerous, including ease of installation and multi-platform support.




The paper is structured as follows:
\secref{klotz} presents the essential characteristics of Klotz. It progressively presents Klotz' features by giving short and concise illustrative scripts. 
\secref{implementation} briefly describes the main points of Klotz implementation and gives some benchmarks.
\secref{conclusion} concludes.


% What is the problem
% Why is the problem a problem?
% What's the surprising Idea?
% What's the consequence?

%:%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Klotz} \seclabel{klotz}

%=======
\subsection{Klotz in a nutshell} \seclabel{nutshell}
Klotz is an agile 3D visualization engine. Visualizations are made of cubes and lines. Contrary to other 3D visualization frameworks available on Smalltalk, Klotz maps each graphical element to an object that belongs to an user-defined domain. The visual dimensions of a graphical element is the result of applying metrics on the visualized domain. 

Klotz' objective is to offer a flexible and agile tool to visualize any arbitrary domain expressed in terms of objects and relations without any prior preparation. Visualizations are described by means of a scripting language. Consider the illustrative script:

\begin{lstlisting}[numbers=left]
| subclasses |
subclasses := Magnitude subclasses.
view nodes: subclasses.
view applyLayout: KLSphereLayout new.

view node: KLEaselCommand using: (KLCube new fillColor: Color green).
view edges: subclasses from: #yourself to: #superclass.   
\end{lstlisting}

Line 1 defines a temporary variable \ct{subclasses}. 
The variable is initialized in Line 2 with the all the subclasses of the class \ct{Magnitude}.
Line 3 adds the objects referenced by \ct{subclasses} into the view. Each of the subclass of \ct{Magnitude} is represented by a cube.
Line 4 positions each cube on an invisible sphere.

Line 6 adds a new node, \ct{Magnitude}, the root of the class hierarchy. The node is colored in green.
Line 7 adds as many edges there are elements in the variable \ct{subclasses}. For each subclass, an edge is drawn from the subclass to its superclass, \ct{Magnitude}. The result is depicted in \figref{figure1.png}.

\fig{h}{0.4}{figure1.png}{Magnitude subclasses.}

\rj{this needs to be fully estructured, i am adding it on demand of the reviewers, whom want a explanation on its diferences}
Klotz is intended to be suplementary 3D version of Mondrian, its graphic engine is not based on it tought, but built from the ground.
The interface is as similar as it can be to Mondrian's, but its intention is not to bring the same visualizations to 3D figures, 
but to add new means to analyse code on another perspective, with another dimention to add more information on the object representation itself.


\fig{h}{0.5}{klotz}{The Klotz Easel}
\rj{it also remarks that we need to remark the difference with other approaches}
Agility of Klotz is expressed via an easel to interactively ``compose'' a visualization (\figref{klotz}). The lower part contains the scripts what is entered by the user. The upper part contains the visualization generated by the script interpretation.



%=======
\subsection{Scripting visualizations with Klotz} \seclabel{scripting}
	
The Klotz scripting language is plain Smalltalk code. Each script is based on 4 principles:

\begin{itemize}
\item Elements composing the visualization are represented as \emph{nodes}. Each node may have a shape and color that reflect some characteristics of the represented node.
\item Relations between elements are represented with \emph{edges}. The color and width of a shape depend on some arbitrary characteristics of connected objects.
\item Elements may be ordered using \emph{layouts}. A layout may use edges to direct the ordering.
\item Containment is expressed with a \emph{view}, an object that enables the construction of the visualization by offering numerous methods.%\ab{Is there more to say?}
\end{itemize}

%to manage the interaction between the elements on the \emph{view}:
%The use of \emph{nodes}(i) to represent the elements that are
%displayed, \emph{edges}(ii) to represent the relationship between
%the selected \emph{nodes}, \emph{Layouts}(iii) to define the way the
%\emph{view} distributes the objetcs on itself, and a special value
%system defined by Pharo symbols used to access to properties of
%the object being modeled (iv).  

The scripting language supports 4 different ways of defining nodes. 
The message \ct{node:} creates an individual node using some default visual properties (colored in blue, thin black border line). A variant of it is \ct{nodes:} to add multiple nodes in one single instruction. The script 

\begin{lstlisting}
view node: Magnitude.
view node: Number.
view node: Time    
\end{lstlisting}

is equivalent to

\begin{lstlisting}
view nodes: { Magnitude. Number . Time}
\end{lstlisting}

The result is shown in \figref{figure2.png}.

\fig{h!}{0.2}{figure2.png}{\ct{Magnitude}, \ct{Number} and \ct{Time}.}

The visual representation may be particularized according to some characteristics of the provided nodes. The message \ct{node:using:} and \ct{nodes:using:} allow graphical cube to be customized with metrics computed on the represented model. Consider the example, depicted in \figref{figure3.png}:

\begin{lstlisting}
view nodes: Magnitude subclasses using: (KLCube new height: #numberOfInstanceVariables)    
\end{lstlisting}

\fig{h}{0.3}{figure3.png}{Magnitude subclasses, the heights shows the number of instance variables.}

The message \ct{numberOfInstanceVariables} is sent to each of \ct{Magnitude}'s subclasses. The result of \texttt{number\-Of\-Instance\-Variables} defines the height of the node.

%Similarly with nodes edges are defined in one of four ways. 
The methods \ct{edge:from:to:} and \ct{edges:from:to:} use default black and thin line shape offered by the view. \figref{figure4.png} shows the result of the script:

\begin{lstlisting}
view nodes: Magnitude subclasses.	
view edges: (Magnitude subclasses) from: #yourself to: MetacelloVersionNumber
\end{lstlisting}
\fig{h}{0.3}{figure4.png}{Basic edges}


% on the current \emph{nodes} the scripting
%language uses the instruction \emph{applyLayout:}. \emph{Layouts}
%define the methods (or metrics) that will be used to decide how
%to display the elements.The application of a \emph{Layout} will 
%affect every \emph{node}(\emph{edge}) defined before itself.
%\rj{color example removed :P, every "numbers" examples changed}
 
 The message \ct{edges:} \emph{domain} \ct{from:} \emph{fromSelectorOrBlock} \ct{to:} \emph{toSelectorOrBlock} constructs an edge for each element of the \emph{domain}. The source code is the result of evaluating \emph{fromSelectorOrBlock} on the considered  node and the target is obtained by evaluating  \emph{toSelectorOrBlock}. One-arg blocks and symbols are equally accepted.
 
  
%The special value system mentioned before is a way of sending
%messages to \emph{nodes} or \emph{edges} that will be evaluated
%before drawing, and will mean something specific at that context:
%keywords like \emph{yourself}, \emph{class}, \emph{subclass}, etc.
%Who are mesages in Pharo, are interpreted by the graphic
%elements (\emph{cubes} and \emph{lines}) to define values
%coresponding to \emph{nodes} (\emph{edges}) information. 

%=======

\subsection{The third dimension} \seclabel{3d}

Visualizations in third dimensions convey a ``feeling of immersion'' that Klotz is intensively exploiting. A number of tools and options are offered by either the visualization or the easel.

\paragraph{Light intensity}
A visualization contains one unique light, a white light located at the same position than the camera. The light intensity on a face is at its maximum when the face is orthogonal to the camera. When a surface of the face is close to be lined up with a light ray, the face is dark.

\paragraph{Emphasizing the perspective}
Perspective is the way a solid object is drawn on a two-dimensional surface so as to give the right impression of their height, width and depth. Our experience shows that it is difficult to precisely compare element positions when closely located from each other. Perspective may be emphasized thanks to an increase and decrease perspective commands offered by the easel.

%The perspective can be managed, and parametrized,
%in order to emphasize changes on the same
%\emph{model}. The easel provides commands to increase 
%(decrease) the perspective, where increasing the
%perspective means to enlarge the length of the edges on the
%third dimension. 

\fig{h}{0.5}{perspective}{Emphasizing the perspective}

\figref{perspective} illustrates this situation with a slight variation in the perspective.

\paragraph{Controlling the camera}
A user looks at a visualization through the view camera. The easel offers six commands to rotate and move the camera along every axis. 
%The position of the camera used to render 
%In order to manage the position of the viewer the easel 
%contains 6 commands to rotate, it provides rotation on 
%every axis, on both directions. It includes commands
%to rotate around the X axis (up and down), around the
%Y axis (rotate left, rotate right) and around the Z axis
%(left and right). It also contains commands to manage
%the current zoom of the \emph{view} (Zoom in and Zoom out),
%an example panel with some script example of visualizations
%and a previous scripts pane, to remember prior launched examples
%on the easel. Finally, it contains commands to manage the 
%perspective, understanding that managing perspective means
%changing the relative position of the viewer.  
%   

\paragraph{Layout}
Nodes are ordered using a layout. The default layout that is used when no other is specified is the horizontal line layout. A layout is specified using the message \ct{applyLayout:}. Four additional layouts are available: cube layout, sphere layout, block layout, and scatterplot layout.

\emph{Cube Layout}: This \emph{layout} orders the nodes in a three-dimensional cube.

%it calculates the nearest perfect cube (8,27,64,etc.), to the
%number of elements, and display the \emph{nodes}, cube root 
%of the result for each direction. if the element are less,
%it leaves the rest blank.

\begin{lstlisting}
view 
	nodes: Magnitude withAllSubclasses 
	using: (KLCube new width: #numberOfInstanceVariables).
view applyLayout: (KLCubeLayout new). 
\end{lstlisting}
\fig{}{0.3}{cubeLayout}{Cube Layout}

\emph{Sphere Layout}: nodes are located on the surface of a sphere, centered on the center of the view. The following example places all the subclasses of \ct{Magnitude} on a sphere (\figref{sphereLayout}):

\begin{lstlisting}
view nodes: Magnitude subclasses. 
view applyLayout: KLSphereLayout new. 

view 
	node: Magnitude 
	using: (KLCube new fillColor: Color green). 
view 
	edges: Magnitude subclasses 
	from: #yourself 
	to: #superclass.
\end{lstlisting}
\fig{}{0.4}{sphereLayout}{Sphere Layout}

\emph{Block Layout}: nodes are hierarchically grouped and organized on a surface. Each group is uniquely colored. The assigned color is randomly chosen if none is specified in the shape.

%It is a \emph{layout} that can be used to 
%analyze diferences between packages. It works with the concept
%of \emph{blocks} wich are the representation of related \emph{nodes}
%as a single entity. Each \emph{block} is diferenced by color and the
%chosen analysis for each \emph{block} is completely defined by the
%user. The \emph{blocks} are displayed in a way that the bigger one
%can be easily visualized.

The following script visualizes the structure of Klotz (\figref{figure9.png}): 
\newpage
\begin{lstlisting}
| shape packages block |
shape := KLCube new 
				height: #numberOfInstanceVariables.
packages := 
	PackageInfo allPackages 
		select: [:pak | pak packageName matches: 'Klotz-*'].

block := KLBlockLayout new.
packages do: [ :pak | 
	block with: {view nodes: pak classes using: shape } ].
view applyLayout: block
	\end{lstlisting}
\fig{}{0.4}{figure9.png}{Block Layout}

The script gives a randomly chosen color to each package of Klotz. The color is used to paint the classes of each package. Each node is a colored class. The height represents the number of attributes. 

\emph{Scatterplot layout}: nodes may be located on a three dimensional Cartesian. Each node has a 3d coordinate that is determined from applying three metric on the represented model. The following script plots each class of the Klotz-Kernel package along its number of attributes, number of methods (\figref{scatterplotLayout}):

\begin{lstlisting}
view nodes: 
	((PackageInfo named:'Klotz-Kernel') classes).

view applyLayout: 
(KLScatterCubeLayout new
    <i>"blue line"</i>
    x: [:cls | cls numberOfLinesOfCode / 1000]; 
    y: #numberOfInstanceVariables; <i>"red line"</i>
    z: #numberOfMethods) <i>"green line"</i>
\end{lstlisting}

\fig{h}{0.4}{scatterplotLayout}{The Klotz Kernel Package}

%This visualization show some tendencies (figure 11):
%most classes in the package are quite simple and similar,
%with few attributes and instance variables (low x and y), and 
%also most of those with lots of attributes and instance variables
%are also those with lots of methods, high depth (high z). Knowing
%this tendencies its easy to tell which classes hold great 
%responsibility on the system.

%=======
%\subsection{Properties} \seclabel{properties}
%
%\begin{itemize}
%\item \emph{The visualization engine should be domain independent.}
%Visualization is a mean to abstract models by compressing a detailed model into a set of visual patterns. The visualization engine we built visualizes any arbitrary domain. According to the experience gained with Mondrian, this is a highly relevant characteristic.
%
%%the engine itself must have a system to generate \emph{abstract analisys},
%%analisys of features that are not yet evaluated when are defined, 
%%for any kind of (numerable) property that could be needed. This way
%%the \emph{model} will only define the values to be represented, not
%%the way they will be displayed.
%
%%\item \emph{Visualizations should be easily composed from simpler parts.}
%%Every visualization needs to be varible, there is no use in  defining
%%any posible visualization, so it must be a composition of simple elements,
%%that can be manage to achieve the display defined on the visualization kind.
%%Representing kinds of visualizations as \emph{layouts}, elements as \emph{nodes},
%%and relations as \emph{edges} is a easy to understand way of composing a
%%vizualization.
% 
%\item \emph{The visualization should be definable at a fine grained level.}
%As mentioned before, representing visualizations as \emph{layouts}, elements as 
%\emph{nodes}, and relations as \emph{edges} gives the posibility to 
%manage every aspect of a visualization on its definition. Every wanted
%property to be display can be part the definition of the \emph{nodes},
%any relation needed can be manage with \emph{edges} and for the actual display
%there are the \emph{layouts}.
%
%\item \emph{The visualization description should be declarative.}
%In order to represent the required visualization, without having to 
%actually learn the base lenguage code, the scripting lenguage itself
%must express the logic of the computation without describing the control 
%flow. Smalltalk is a lenguage that follows this paradigm, but this is
%hardly enougth to make the script easy to follow. The actual computation
%behind the system is controlled by the instructions \emph{node:/nodes:}, 
%\emph{edge:/edges:} and \emph{applyLayout:}. Most times, the visualization
%need more than just this instructions, it needs to control the \emph{shape}
%of both \emph{nodes} and \emph{edges}, with the instruction \emph{using:}. 
%For the \emph{layouts}, every \emph{layout} contains its own structure to 
%define its parameters.   
%\end{itemize}

%:%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{Applications} \seclabel{applications}
%
%%=======
%\subsection{Codecity}
%A natural application of the block layout is to visualize software as an interactive city. Consider the representation of two packages of the Pharo compiler, the parse nodes and the kernel (\figref{figure10.png}):
%
%\begin{lstlisting}
%view applyLayout: (KLBlockLayout new
%	with: {view nodes: ((PackageInfo named:'Compiler-ParseNodes') classes) 
%		using: (KLCube new width: #numberOfMethods; 
%							height: #numberOfInstanceVariables; 
%							depth:#numberOfMethods;
%							fillColor: Color lightBlue;
%							 yourself)};
%	with: {view nodes: ((PackageInfo named: 'Compiler-Kernel') classes)
%		using: (KLCube new width: #numberOfMethods; 
%							height: #numberOfInstanceVariables; 
%							depth:#numberOfMethods;
%							fillColor: Color blue;
%							yourself)})
%\end{lstlisting}
%
%\fig{}{0.55}{figure10.png}{Compiler Kernel and ParseNodes}
%
%This codecity-like visualization is useful when looking for smelly code or opportunities for code refactoring.
%
%This kind visualization expresses useful information when looking for
%smelly code or wanting to do some refactoring. The code before give 3 
%conclutions, among others, that come directly from figure 10:
%every class of these 2 packages are highly functional, they are not
%meant to actually represent a structure with lots of variables, which
%is consistent with their real purpose. The \emph{ParseNodes} package
%functionalities are concentrated on 3 classes (B in the figure), 
%again consist with already known information (\emph{ParseNode}, 
%\emph{BlockNode} and \emph{MessageNode} classes). Also the {Kernel} 
%package contain clases with no instance variables at all (A in the figure),
%wich is also consistent with verifiable information (every subclass of 
%\emph{BytecodeEncoder} have no instance variables. 
%
%
%%=======
%\subsection{Scatterplot}
%Tipically, to represent code properties directly as the dimentions
%of the \emph{nodes} is not necesarily the best way to compare 
%them, sometimes is usefull enought to compare such measures to 
%just contrast the values themselves. Using a scatter plot, 
%a type of mathematical diagram that use Cartesian coordinates to 
%display values for 2 (or 3 on our 3D \emph{model}) variables for 
%a set of data, the \emph{nodes} just represent the entity itself, 
%and the properties are  parametrized with the \emph{node} position.
%
%Using the \emph{Scatter Cube Layout}, 3D scatter plot can be defined
%in a simple intruction. The following code presents an analisys of
%the \emph{Klotz-Kernel} package:
%
%\begin{lstlisting}
%view nodes: 
%	((PackageInfo named:'Klotz-Kernel') classes).
%
%view applyLayout: 
%(KLScatterCubeLayout new
%    x: #numberOfAttributes; <i>"blue line"</i>
%    y: #numberOfInstanceVariables; <i>"red line"</i>
%    z: #numberOfMethods) <i>"green line"</i>
%\end{lstlisting}
%
%\fig{}{0.4}{figure11.png}{The Klotz Kernel Package}
%
%This visualization show some tendencies (figure 11):
%most classes in the package are quite simple and similar,
%with few attributes and instance variables (low x and y), and 
%also most of those with lots of attributes and instance variables
%are also those with lots of methods, high depth (high z). Knowing
%this tendencies its easy to tell which classes hold great 
%responsibility on the system.
%



%:%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation} \seclabel{implementation}	
\rj{we need to add some time reference here, either say that this quantities can be handled by Klotz without colapsing or say that it keeps
working just fine with them}
The current version of \emph{Klotz}, yet not optimized, provides
support up to 1000 \emph{nodes} on screen, as well as, 
1000 \emph{edges} between these \emph{nodes}.

\fig{}{0.5}{graph1}{Benchmark (quantity vs time[ms]) for few \emph{nodes}/\emph{edges}} 

As shown in \figref{graph1}, the time taken for the easel to render a scene with the default horizontal line layout is almost proportional with the quantity of nodes and edges. %It also shown not major difference between the computation of different kinds of \emph{Layouts}, even those using \emph{edges}. 

\fig{}{0.5}{graph2}{Benchmark (quantity vs time[ms]) for lots of \emph{nodes}/\emph{edges}}

On \figref{graph2} illustrates the linear resource taken by the layouts.

\rj{this may need a subsection itself, but the reviewers ask for a detailed explanation on the contruction of the 3D objetcs, and if posible an encounter problem}
The Klotz graphic engine its based on the construction of polygons that are later rendered as regular 2D Morphs. These polygons vertices are calculated using tridimentional vectors with absolute coordinates, and using matrices to produce each transformation (from zooming to the perspective transformation into 2D points). The 3D shapes are also basically optimised, the hidden faces (calculated to some point by need) are not rendered. These calculations, easy as they sound, are often troublesome since calculation for coordinates requires decent, and fast, calculations that sometimes can show perfectly reasonable results in theory (like a point located on the infinity) that must be taken care with proper aproximations, wich must also fix the not accurate aproximations made by the Integer/Float classes.

The Klotz graphic generation solely uses Morph facilities. The most common approach to visualize 3D graphics is to use OpenGL, a reference in the field. We deliberately decided to not use OpenGL for a number of practical reasons:

\begin{itemize}
\item OpenGL is distributed as a set of natives libraries, depending on the operating system. Libraries are accessed within Pharo using FFI or Alien, two technologies that interoperate with native libraries. Unfortunately, the recent advances with the Pharo virtual machine significantly reduced the usability of accessing external libraries.

\rj{i am not sure if taking it into account but this argument is remarked as bad. I think its either not explicit or it need a bigger comment on the use of a Morphic based engine}
\item The visualizations produced with Mondrian rarely go over 2,000 nodes and 1,000 edges. It is reasonable to expect similar figure as the upper limit for Klotz. OpenGL enables sophisticated rendering, including a high number of rendered polygons and advanced light composition. We do not expect to have such a need in a close future.
\end{itemize}

Basing Klotz on OpenGL is clearly on our agenda. For this, Alien needs to gain stability, especially with the Pharo JIT virtual machine (Cog).

%:%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Related Work} \seclabel{relatedwork}
\rj{just copy-pasting "Related work seems to be unfinished (also remove the annotation): Jun, http://scg.unibe.ch/scgbib?
query=christoph+wysseier, http://www.chromeexperiments.com/ "}
\subsection{Lumiere}
Lumiere~\cite{Oliv09a} is a 3D Framework,that applies a stage metaphor.
This metaphor implies that all graphics are produced by cameras
taking pictures of 3D shapes lit by the lights of the stage. A
stage provides the setting for taking pictures of a composition 
of visual objects we call micro-worlds. Lumiere's objective
is to implement a 3D graphical support to Pharo programmers, at
a high level of abstraction. This framework uses OpenGL. As mentioned before, this libraries are 
entirely dependent of the OS and the right native OpenGL packages
within the machine itself, to be used.

On the other hand, Klotz do not represent a competitor on that 
matter, Klotz is a 3D code visualization engine, its goal is
not focus on the actual quality of the graphic interface, but 
on the expressiveness of the representation in order to achieve
a better comprehension of the code. Right now Klotz graphical
interface is a small engine that is completely based on the Morph
engine. This does not
mean to be the final core, eventually the system will need an
external graphic engine, probably based on OpenGL, and that can
also be Lumiere itself.

\subsection{CodeCity}
CodeCity~\cite{Wett08d} is a full fledged city metaphor environment, for code
analisys. Its visualization is based on this metaphor, and its
metrics are entirely defined (and chosen carefully) to faithfully
explain software code. This concrete approach intends to focus
not only on the visualization itself, but in the analysis of software
evolution. It also support  reverse engineering.

CodeCity is programmed in VisualWorks Smalltalk on top of the Moose 
platform, just like Lumiere, it uses OpenGL for rendering.

When it comes to Klotz, not been as expressive as Codecity, eventually, 
and depending on the programer's skills, it can implement most  
aspect of its model. 
%The same metrics defined on it to represent code can be applied to a yet customizable environment, with a simple Pharo image. This can be very complex and carry lots of trouble that CodeCity has already fixed (probably). 
%meant to easily display many different aspects of a code analysis on the 
%same framework and with a scripting language, designed to be easy to manage.


%:%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion} \seclabel{conclusion}
\rj{I dont know how much time you got to take care of this remarks but the reviewers asked for a download reference}
Klotz is an agile three-dimensional visualization engine. Klotz visualizes a graph of objects, without any preparation of the objects.
Klotz modeling system allows one to change a graph definition easily, making it simple and fast to adjust a desired visualization. Been based on any object as the items represented on the node it gives great dynamism to the kind of visualization that it can provide. 
As future work, we plan to:
\begin{itemize}
\item Implement drag-and-drop support to manage the nodes easily.
\item Add an interface to see the information within the node on mouse focus, and change it dynamically.
\item Optimize and improve the graphical libraries, if possible, change to a stable, OpenGL based library.
\item Add lots of new Layouts, and with time, other figures to use as nodes. 
\end{itemize}

\paragraph{Acknowledgment} 
We thank Patricio Plaza for his effort and participation on an early version of Klotz.

%{\small 
%\paragraph{Acknowledgment.} We thank Mircea Lungu, Oscar Nierstrasz, Lukas Renggli and Romain Robbes for the multiple discussions we had and their comments on an early draft of the paper.
%We particular thank Walter Binder for his multiple discussions and advices.
%Our thanks also go to Eliot Miranda for his help on porting \compteur to Cog, the jitted virtual machine of Pharo. 
%We thank Gilad Bracha and Jan Vran\'{y} for the fruitful discussions we had.
%We also thank Andrew P. Black for his precious help on improving the paper.
%We gratefully thank Mar\'ia Jos\'e Cires for her help on the statistical part. 
%We also thank ESUG, the European Smalltalk User Group, for its financial contribution to the presentation of this paper. 
%}
%

\bibliographystyle{plain}
\bibliography{scg}


\end{document}
